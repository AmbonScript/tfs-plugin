<div>
  <p>
    A collection of server paths to cloak to prevent their inclusion in the workspace.
    Paths that are cloaked will not be pulled into the local workspace during a GET
    from TFS or VSTS.
  </p>
  <p>
    Multiple entries must be placed onto separate lines.
  </p>
  <p>
    For example, suppose the <b>Project path</b> is <tt>$/Example/project/path</tt>,
    and the repository contains the following subfolders:
    <blockquote>
      $/Example/project/path/A <br />
      $/Example/project/path/A/1 <br />
      $/Example/project/path/A/2 <br />
      $/Example/project/path/B <br />
      $/Example/project/path/C <br />
    </blockquote>
    Now, suppose the following paths were entered as <b>Cloaked Paths</b>:
    <blockquote>
      $/Example/project/path/A/2 <br />
      $/Example/project/path/B <br />
    </blockquote>
    ...then the resulting workspace on the Jenkins server would only have the following folders:
    <blockquote>
      $/Example/project/path/A <br />
      $/Example/project/path/A/1 <br />
      $/Example/project/path/C <br />
    </blockquote>
    ...and check-ins that contain files only in cloaked folders (in other words, fully cloaked)
    will not trigger a build,
  whereas a check-in containing any path that isn't cloaked will trigger a build.
  </p>
  <p>
    For example, the following check-in <em>will not</em> trigger a build,
    because it only contains changes under cloaked paths:
    <blockquote>
      $/Example/project/path/A/2/alpha.txt <br />
      $/Example/project/path/A/2/second.txt <br />
      $/Example/project/path/B/bravo.txt <br />
    </blockquote>
    ...whereas this check-in <em>will</em> trigger a build,
    because it contains at least one path that isn't cloaked:
    <blockquote>
      $/Example/project/path/A/1/first.txt <br />
      $/Example/project/path/A/2/second.txt <br />
      $/Example/project/path/B/bravo.txt <br />
    </blockquote>
  </p>
</div>
